/*
 * Mattermost API Reference
 *
 * There is also a work-in-progress [Postman API reference](https://documenter.getpostman.com/view/4508214/RW8FERUn). 
 *
 * The version of the OpenAPI document: 4.0.0
 * Contact: feedback@mattermost.com
 * Generated by: https://openapi-generator.tech
 */

#[allow(unused_imports)]
use std::rc::Rc;

use std::option::Option;

use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};


/// struct for typed errors of method `channels_channel_id_convert_post`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChannelsChannelIdConvertPostError {
    Status400(crate::models::AppError),
    Status401(crate::models::AppError),
    Status403(crate::models::AppError),
    Status404(crate::models::AppError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `channels_channel_id_delete`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChannelsChannelIdDeleteError {
    Status400(crate::models::AppError),
    Status401(crate::models::AppError),
    Status403(crate::models::AppError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `channels_channel_id_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChannelsChannelIdGetError {
    Status401(crate::models::AppError),
    Status403(crate::models::AppError),
    Status404(crate::models::AppError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `channels_channel_id_member_counts_by_group_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChannelsChannelIdMemberCountsByGroupGetError {
    Status400(crate::models::AppError),
    Status401(crate::models::AppError),
    Status403(crate::models::AppError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `channels_channel_id_members_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChannelsChannelIdMembersGetError {
    Status400(crate::models::AppError),
    Status401(crate::models::AppError),
    Status403(crate::models::AppError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `channels_channel_id_members_ids_post`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChannelsChannelIdMembersIdsPostError {
    Status400(crate::models::AppError),
    Status401(crate::models::AppError),
    Status403(crate::models::AppError),
    Status404(crate::models::AppError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `channels_channel_id_members_minus_group_members_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChannelsChannelIdMembersMinusGroupMembersGetError {
    Status400(crate::models::AppError),
    Status401(crate::models::AppError),
    Status403(crate::models::AppError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `channels_channel_id_members_post`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChannelsChannelIdMembersPostError {
    Status400(crate::models::AppError),
    Status401(crate::models::AppError),
    Status403(crate::models::AppError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `channels_channel_id_members_user_id_delete`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChannelsChannelIdMembersUserIdDeleteError {
    Status400(crate::models::AppError),
    Status401(crate::models::AppError),
    Status403(crate::models::AppError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `channels_channel_id_members_user_id_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChannelsChannelIdMembersUserIdGetError {
    Status400(crate::models::AppError),
    Status401(crate::models::AppError),
    Status403(crate::models::AppError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `channels_channel_id_members_user_id_notify_props_put`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChannelsChannelIdMembersUserIdNotifyPropsPutError {
    Status400(crate::models::AppError),
    Status401(crate::models::AppError),
    Status403(crate::models::AppError),
    Status404(crate::models::AppError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `channels_channel_id_members_user_id_roles_put`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChannelsChannelIdMembersUserIdRolesPutError {
    Status400(crate::models::AppError),
    Status401(crate::models::AppError),
    Status403(crate::models::AppError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `channels_channel_id_members_user_id_scheme_roles_put`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChannelsChannelIdMembersUserIdSchemeRolesPutError {
    Status400(crate::models::AppError),
    Status401(crate::models::AppError),
    Status403(crate::models::AppError),
    Status404(crate::models::AppError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `channels_channel_id_moderations_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChannelsChannelIdModerationsGetError {
    Status400(crate::models::AppError),
    Status401(crate::models::AppError),
    Status403(crate::models::AppError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `channels_channel_id_moderations_patch_put`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChannelsChannelIdModerationsPatchPutError {
    Status400(crate::models::AppError),
    Status401(crate::models::AppError),
    Status403(crate::models::AppError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `channels_channel_id_move_post`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChannelsChannelIdMovePostError {
    Status400(crate::models::AppError),
    Status401(crate::models::AppError),
    Status403(crate::models::AppError),
    Status404(crate::models::AppError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `channels_channel_id_patch_put`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChannelsChannelIdPatchPutError {
    Status400(crate::models::AppError),
    Status401(crate::models::AppError),
    Status403(crate::models::AppError),
    Status404(crate::models::AppError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `channels_channel_id_pinned_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChannelsChannelIdPinnedGetError {
    Status400(crate::models::AppError),
    Status401(crate::models::AppError),
    Status403(crate::models::AppError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `channels_channel_id_privacy_put`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChannelsChannelIdPrivacyPutError {
    Status400(crate::models::AppError),
    Status401(crate::models::AppError),
    Status403(crate::models::AppError),
    Status404(crate::models::AppError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `channels_channel_id_put`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChannelsChannelIdPutError {
    Status400(crate::models::AppError),
    Status401(crate::models::AppError),
    Status403(crate::models::AppError),
    Status404(crate::models::AppError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `channels_channel_id_restore_post`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChannelsChannelIdRestorePostError {
    Status401(crate::models::AppError),
    Status403(crate::models::AppError),
    Status404(crate::models::AppError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `channels_channel_id_scheme_put`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChannelsChannelIdSchemePutError {
    Status400(crate::models::AppError),
    Status401(crate::models::AppError),
    Status403(crate::models::AppError),
    Status501(crate::models::AppError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `channels_channel_id_stats_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChannelsChannelIdStatsGetError {
    Status400(crate::models::AppError),
    Status401(crate::models::AppError),
    Status403(crate::models::AppError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `channels_channel_id_timezones_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChannelsChannelIdTimezonesGetError {
    Status400(crate::models::AppError),
    Status401(crate::models::AppError),
    Status403(crate::models::AppError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `channels_direct_post`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChannelsDirectPostError {
    Status400(crate::models::AppError),
    Status401(crate::models::AppError),
    Status403(crate::models::AppError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `channels_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChannelsGetError {
    Status400(crate::models::AppError),
    Status401(crate::models::AppError),
    Status404(crate::models::AppError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `channels_group_post`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChannelsGroupPostError {
    Status400(crate::models::AppError),
    Status401(crate::models::AppError),
    Status403(crate::models::AppError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `channels_group_search_post`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChannelsGroupSearchPostError {
    Status400(crate::models::AppError),
    Status401(crate::models::AppError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `channels_members_user_id_view_post`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChannelsMembersUserIdViewPostError {
    Status400(crate::models::AppError),
    Status401(crate::models::AppError),
    Status403(crate::models::AppError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `channels_post`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChannelsPostError {
    Status400(crate::models::AppError),
    Status401(crate::models::AppError),
    Status403(crate::models::AppError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `channels_search_post`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ChannelsSearchPostError {
    Status400(crate::models::AppError),
    Status401(crate::models::AppError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `teams_name_team_name_channels_name_channel_name_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamsNameTeamNameChannelsNameChannelNameGetError {
    Status401(crate::models::AppError),
    Status403(crate::models::AppError),
    Status404(crate::models::AppError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `teams_team_id_channels_autocomplete_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamsTeamIdChannelsAutocompleteGetError {
    Status400(crate::models::AppError),
    Status401(crate::models::AppError),
    Status403(crate::models::AppError),
    Status404(crate::models::AppError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `teams_team_id_channels_deleted_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamsTeamIdChannelsDeletedGetError {
    Status400(crate::models::AppError),
    Status401(crate::models::AppError),
    Status403(crate::models::AppError),
    Status404(crate::models::AppError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `teams_team_id_channels_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamsTeamIdChannelsGetError {
    Status400(crate::models::AppError),
    Status401(crate::models::AppError),
    Status403(crate::models::AppError),
    Status404(crate::models::AppError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `teams_team_id_channels_ids_post`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamsTeamIdChannelsIdsPostError {
    Status400(crate::models::AppError),
    Status401(crate::models::AppError),
    Status404(crate::models::AppError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `teams_team_id_channels_name_channel_name_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamsTeamIdChannelsNameChannelNameGetError {
    Status401(crate::models::AppError),
    Status403(crate::models::AppError),
    Status404(crate::models::AppError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `teams_team_id_channels_search_archived_post`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamsTeamIdChannelsSearchArchivedPostError {
    Status400(crate::models::AppError),
    Status401(crate::models::AppError),
    Status403(crate::models::AppError),
    Status404(crate::models::AppError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `teams_team_id_channels_search_autocomplete_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamsTeamIdChannelsSearchAutocompleteGetError {
    Status400(crate::models::AppError),
    Status401(crate::models::AppError),
    Status403(crate::models::AppError),
    Status404(crate::models::AppError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `teams_team_id_channels_search_post`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TeamsTeamIdChannelsSearchPostError {
    Status400(crate::models::AppError),
    Status401(crate::models::AppError),
    Status403(crate::models::AppError),
    Status404(crate::models::AppError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `users_user_id_channels_channel_id_unread_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersUserIdChannelsChannelIdUnreadGetError {
    Status400(crate::models::AppError),
    Status401(crate::models::AppError),
    Status403(crate::models::AppError),
    Status404(crate::models::AppError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `users_user_id_teams_team_id_channels_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersUserIdTeamsTeamIdChannelsGetError {
    Status400(crate::models::AppError),
    Status401(crate::models::AppError),
    Status403(crate::models::AppError),
    Status404(crate::models::AppError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method `users_user_id_teams_team_id_channels_members_get`
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UsersUserIdTeamsTeamIdChannelsMembersGetError {
    Status400(crate::models::AppError),
    Status401(crate::models::AppError),
    Status403(crate::models::AppError),
    UnknownValue(serde_json::Value),
}


    pub async fn channels_channel_id_convert_post(configuration: &configuration::Configuration, channel_id: &str) -> Result<crate::models::Channel, Error<ChannelsChannelIdConvertPostError>> {
        let client = &configuration.client;

        let uri_str = format!("{}/channels/{channel_id}/convert", configuration.base_path, channel_id=crate::apis::urlencode(channel_id));
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<ChannelsChannelIdConvertPostError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn channels_channel_id_delete(configuration: &configuration::Configuration, channel_id: &str) -> Result<crate::models::StatusOk, Error<ChannelsChannelIdDeleteError>> {
        let client = &configuration.client;

        let uri_str = format!("{}/channels/{channel_id}", configuration.base_path, channel_id=crate::apis::urlencode(channel_id));
        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<ChannelsChannelIdDeleteError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn channels_channel_id_get(configuration: &configuration::Configuration, channel_id: &str) -> Result<crate::models::Channel, Error<ChannelsChannelIdGetError>> {
        let client = &configuration.client;

        let uri_str = format!("{}/channels/{channel_id}", configuration.base_path, channel_id=crate::apis::urlencode(channel_id));
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<ChannelsChannelIdGetError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn channels_channel_id_member_counts_by_group_get(configuration: &configuration::Configuration, channel_id: &str, include_timezones: Option<bool>) -> Result<(), Error<ChannelsChannelIdMemberCountsByGroupGetError>> {
        let client = &configuration.client;

        let uri_str = format!("{}/channels/{channel_id}/member_counts_by_group", configuration.base_path, channel_id=crate::apis::urlencode(channel_id));
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = include_timezones {
            req_builder = req_builder.query(&[("include_timezones", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            Ok(())
        } else {
            let entity: Option<ChannelsChannelIdMemberCountsByGroupGetError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn channels_channel_id_members_get(configuration: &configuration::Configuration, channel_id: &str, page: Option<i32>, per_page: Option<i32>) -> Result<Vec<crate::models::ChannelMember>, Error<ChannelsChannelIdMembersGetError>> {
        let client = &configuration.client;

        let uri_str = format!("{}/channels/{channel_id}/members", configuration.base_path, channel_id=crate::apis::urlencode(channel_id));
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = page {
            req_builder = req_builder.query(&[("page", &s.to_string())]);
        }
        if let Some(ref s) = per_page {
            req_builder = req_builder.query(&[("per_page", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<ChannelsChannelIdMembersGetError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn channels_channel_id_members_ids_post(configuration: &configuration::Configuration, channel_id: &str, request_body: Vec<String>) -> Result<Vec<crate::models::ChannelMember>, Error<ChannelsChannelIdMembersIdsPostError>> {
        let client = &configuration.client;

        let uri_str = format!("{}/channels/{channel_id}/members/ids", configuration.base_path, channel_id=crate::apis::urlencode(channel_id));
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };
        req_builder = req_builder.json(&request_body);

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<ChannelsChannelIdMembersIdsPostError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn channels_channel_id_members_minus_group_members_get(configuration: &configuration::Configuration, channel_id: &str, group_ids: &str, page: Option<i32>, per_page: Option<i32>) -> Result<(), Error<ChannelsChannelIdMembersMinusGroupMembersGetError>> {
        let client = &configuration.client;

        let uri_str = format!("{}/channels/{channel_id}/members_minus_group_members", configuration.base_path, channel_id=crate::apis::urlencode(channel_id));
        let mut req_builder = client.get(uri_str.as_str());

        req_builder = req_builder.query(&[("group_ids", &group_ids.to_string())]);
        if let Some(ref s) = page {
            req_builder = req_builder.query(&[("page", &s.to_string())]);
        }
        if let Some(ref s) = per_page {
            req_builder = req_builder.query(&[("per_page", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            Ok(())
        } else {
            let entity: Option<ChannelsChannelIdMembersMinusGroupMembersGetError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn channels_channel_id_members_post(configuration: &configuration::Configuration, channel_id: &str, inline_object47: crate::models::InlineObject47) -> Result<crate::models::ChannelMember, Error<ChannelsChannelIdMembersPostError>> {
        let client = &configuration.client;

        let uri_str = format!("{}/channels/{channel_id}/members", configuration.base_path, channel_id=crate::apis::urlencode(channel_id));
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };
        req_builder = req_builder.json(&inline_object47);

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<ChannelsChannelIdMembersPostError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn channels_channel_id_members_user_id_delete(configuration: &configuration::Configuration, channel_id: &str, user_id: &str) -> Result<crate::models::StatusOk, Error<ChannelsChannelIdMembersUserIdDeleteError>> {
        let client = &configuration.client;

        let uri_str = format!("{}/channels/{channel_id}/members/{user_id}", configuration.base_path, channel_id=crate::apis::urlencode(channel_id), user_id=crate::apis::urlencode(user_id));
        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<ChannelsChannelIdMembersUserIdDeleteError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn channels_channel_id_members_user_id_get(configuration: &configuration::Configuration, channel_id: &str, user_id: &str) -> Result<crate::models::ChannelMember, Error<ChannelsChannelIdMembersUserIdGetError>> {
        let client = &configuration.client;

        let uri_str = format!("{}/channels/{channel_id}/members/{user_id}", configuration.base_path, channel_id=crate::apis::urlencode(channel_id), user_id=crate::apis::urlencode(user_id));
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<ChannelsChannelIdMembersUserIdGetError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn channels_channel_id_members_user_id_notify_props_put(configuration: &configuration::Configuration, channel_id: &str, user_id: &str, channel_notify_props: crate::models::ChannelNotifyProps) -> Result<crate::models::StatusOk, Error<ChannelsChannelIdMembersUserIdNotifyPropsPutError>> {
        let client = &configuration.client;

        let uri_str = format!("{}/channels/{channel_id}/members/{user_id}/notify_props", configuration.base_path, channel_id=crate::apis::urlencode(channel_id), user_id=crate::apis::urlencode(user_id));
        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };
        req_builder = req_builder.json(&channel_notify_props);

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<ChannelsChannelIdMembersUserIdNotifyPropsPutError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn channels_channel_id_members_user_id_roles_put(configuration: &configuration::Configuration, channel_id: &str, user_id: &str, inline_object48: crate::models::InlineObject48) -> Result<crate::models::StatusOk, Error<ChannelsChannelIdMembersUserIdRolesPutError>> {
        let client = &configuration.client;

        let uri_str = format!("{}/channels/{channel_id}/members/{user_id}/roles", configuration.base_path, channel_id=crate::apis::urlencode(channel_id), user_id=crate::apis::urlencode(user_id));
        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };
        req_builder = req_builder.json(&inline_object48);

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<ChannelsChannelIdMembersUserIdRolesPutError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn channels_channel_id_members_user_id_scheme_roles_put(configuration: &configuration::Configuration, channel_id: &str, user_id: &str, inline_object49: crate::models::InlineObject49) -> Result<crate::models::StatusOk, Error<ChannelsChannelIdMembersUserIdSchemeRolesPutError>> {
        let client = &configuration.client;

        let uri_str = format!("{}/channels/{channel_id}/members/{user_id}/schemeRoles", configuration.base_path, channel_id=crate::apis::urlencode(channel_id), user_id=crate::apis::urlencode(user_id));
        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };
        req_builder = req_builder.json(&inline_object49);

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<ChannelsChannelIdMembersUserIdSchemeRolesPutError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn channels_channel_id_moderations_get(configuration: &configuration::Configuration, channel_id: &str) -> Result<Vec<crate::models::ChannelModeration>, Error<ChannelsChannelIdModerationsGetError>> {
        let client = &configuration.client;

        let uri_str = format!("{}/channels/{channel_id}/moderations", configuration.base_path, channel_id=crate::apis::urlencode(channel_id));
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<ChannelsChannelIdModerationsGetError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn channels_channel_id_moderations_patch_put(configuration: &configuration::Configuration, channel_id: &str, channel_moderation_patch: crate::models::ChannelModerationPatch) -> Result<Vec<crate::models::ChannelModeration>, Error<ChannelsChannelIdModerationsPatchPutError>> {
        let client = &configuration.client;

        let uri_str = format!("{}/channels/{channel_id}/moderations/patch", configuration.base_path, channel_id=crate::apis::urlencode(channel_id));
        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };
        req_builder = req_builder.json(&channel_moderation_patch);

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<ChannelsChannelIdModerationsPatchPutError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn channels_channel_id_move_post(configuration: &configuration::Configuration, channel_id: &str, inline_object44: crate::models::InlineObject44) -> Result<crate::models::Channel, Error<ChannelsChannelIdMovePostError>> {
        let client = &configuration.client;

        let uri_str = format!("{}/channels/{channel_id}/move", configuration.base_path, channel_id=crate::apis::urlencode(channel_id));
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };
        req_builder = req_builder.json(&inline_object44);

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<ChannelsChannelIdMovePostError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn channels_channel_id_patch_put(configuration: &configuration::Configuration, channel_id: &str, inline_object42: crate::models::InlineObject42) -> Result<crate::models::Channel, Error<ChannelsChannelIdPatchPutError>> {
        let client = &configuration.client;

        let uri_str = format!("{}/channels/{channel_id}/patch", configuration.base_path, channel_id=crate::apis::urlencode(channel_id));
        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };
        req_builder = req_builder.json(&inline_object42);

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<ChannelsChannelIdPatchPutError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn channels_channel_id_pinned_get(configuration: &configuration::Configuration, channel_id: &str) -> Result<crate::models::PostList, Error<ChannelsChannelIdPinnedGetError>> {
        let client = &configuration.client;

        let uri_str = format!("{}/channels/{channel_id}/pinned", configuration.base_path, channel_id=crate::apis::urlencode(channel_id));
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<ChannelsChannelIdPinnedGetError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn channels_channel_id_privacy_put(configuration: &configuration::Configuration, channel_id: &str, inline_object43: crate::models::InlineObject43) -> Result<crate::models::Channel, Error<ChannelsChannelIdPrivacyPutError>> {
        let client = &configuration.client;

        let uri_str = format!("{}/channels/{channel_id}/privacy", configuration.base_path, channel_id=crate::apis::urlencode(channel_id));
        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };
        req_builder = req_builder.json(&inline_object43);

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<ChannelsChannelIdPrivacyPutError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn channels_channel_id_put(configuration: &configuration::Configuration, channel_id: &str, inline_object41: crate::models::InlineObject41) -> Result<crate::models::Channel, Error<ChannelsChannelIdPutError>> {
        let client = &configuration.client;

        let uri_str = format!("{}/channels/{channel_id}", configuration.base_path, channel_id=crate::apis::urlencode(channel_id));
        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };
        req_builder = req_builder.json(&inline_object41);

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<ChannelsChannelIdPutError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn channels_channel_id_restore_post(configuration: &configuration::Configuration, channel_id: &str) -> Result<crate::models::Channel, Error<ChannelsChannelIdRestorePostError>> {
        let client = &configuration.client;

        let uri_str = format!("{}/channels/{channel_id}/restore", configuration.base_path, channel_id=crate::apis::urlencode(channel_id));
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<ChannelsChannelIdRestorePostError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn channels_channel_id_scheme_put(configuration: &configuration::Configuration, channel_id: &str, inline_object51: crate::models::InlineObject51) -> Result<crate::models::StatusOk, Error<ChannelsChannelIdSchemePutError>> {
        let client = &configuration.client;

        let uri_str = format!("{}/channels/{channel_id}/scheme", configuration.base_path, channel_id=crate::apis::urlencode(channel_id));
        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };
        req_builder = req_builder.json(&inline_object51);

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<ChannelsChannelIdSchemePutError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn channels_channel_id_stats_get(configuration: &configuration::Configuration, channel_id: &str) -> Result<crate::models::ChannelStats, Error<ChannelsChannelIdStatsGetError>> {
        let client = &configuration.client;

        let uri_str = format!("{}/channels/{channel_id}/stats", configuration.base_path, channel_id=crate::apis::urlencode(channel_id));
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<ChannelsChannelIdStatsGetError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn channels_channel_id_timezones_get(configuration: &configuration::Configuration, channel_id: &str) -> Result<Vec<String>, Error<ChannelsChannelIdTimezonesGetError>> {
        let client = &configuration.client;

        let uri_str = format!("{}/channels/{channel_id}/timezones", configuration.base_path, channel_id=crate::apis::urlencode(channel_id));
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<ChannelsChannelIdTimezonesGetError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn channels_direct_post(configuration: &configuration::Configuration, request_body: Vec<String>) -> Result<crate::models::Channel, Error<ChannelsDirectPostError>> {
        let client = &configuration.client;

        let uri_str = format!("{}/channels/direct", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };
        req_builder = req_builder.json(&request_body);

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<ChannelsDirectPostError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn channels_get(configuration: &configuration::Configuration, not_associated_to_group: Option<&str>, page: Option<i32>, per_page: Option<i32>, exclude_default_channels: Option<bool>) -> Result<Vec<crate::models::Channel>, Error<ChannelsGetError>> {
        let client = &configuration.client;

        let uri_str = format!("{}/channels", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = not_associated_to_group {
            req_builder = req_builder.query(&[("not_associated_to_group", &s.to_string())]);
        }
        if let Some(ref s) = page {
            req_builder = req_builder.query(&[("page", &s.to_string())]);
        }
        if let Some(ref s) = per_page {
            req_builder = req_builder.query(&[("per_page", &s.to_string())]);
        }
        if let Some(ref s) = exclude_default_channels {
            req_builder = req_builder.query(&[("exclude_default_channels", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<ChannelsGetError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn channels_group_post(configuration: &configuration::Configuration, request_body: Vec<String>) -> Result<crate::models::Channel, Error<ChannelsGroupPostError>> {
        let client = &configuration.client;

        let uri_str = format!("{}/channels/group", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };
        req_builder = req_builder.json(&request_body);

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<ChannelsGroupPostError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn channels_group_search_post(configuration: &configuration::Configuration, inline_object40: crate::models::InlineObject40) -> Result<Vec<crate::models::Channel>, Error<ChannelsGroupSearchPostError>> {
        let client = &configuration.client;

        let uri_str = format!("{}/channels/group/search", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };
        req_builder = req_builder.json(&inline_object40);

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<ChannelsGroupSearchPostError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn channels_members_user_id_view_post(configuration: &configuration::Configuration, user_id: &str, inline_object50: crate::models::InlineObject50) -> Result<crate::models::InlineResponse2008, Error<ChannelsMembersUserIdViewPostError>> {
        let client = &configuration.client;

        let uri_str = format!("{}/channels/members/{user_id}/view", configuration.base_path, user_id=crate::apis::urlencode(user_id));
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };
        req_builder = req_builder.json(&inline_object50);

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<ChannelsMembersUserIdViewPostError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn channels_post(configuration: &configuration::Configuration, inline_object38: crate::models::InlineObject38) -> Result<crate::models::Channel, Error<ChannelsPostError>> {
        let client = &configuration.client;

        let uri_str = format!("{}/channels", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };
        req_builder = req_builder.json(&inline_object38);

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<ChannelsPostError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn channels_search_post(configuration: &configuration::Configuration, inline_object39: crate::models::InlineObject39) -> Result<crate::models::InlineResponse2007, Error<ChannelsSearchPostError>> {
        let client = &configuration.client;

        let uri_str = format!("{}/channels/search", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };
        req_builder = req_builder.json(&inline_object39);

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<ChannelsSearchPostError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn teams_name_team_name_channels_name_channel_name_get(configuration: &configuration::Configuration, team_name: &str, channel_name: &str, include_deleted: Option<bool>) -> Result<crate::models::Channel, Error<TeamsNameTeamNameChannelsNameChannelNameGetError>> {
        let client = &configuration.client;

        let uri_str = format!("{}/teams/name/{team_name}/channels/name/{channel_name}", configuration.base_path, team_name=crate::apis::urlencode(team_name), channel_name=crate::apis::urlencode(channel_name));
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = include_deleted {
            req_builder = req_builder.query(&[("include_deleted", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<TeamsNameTeamNameChannelsNameChannelNameGetError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn teams_team_id_channels_autocomplete_get(configuration: &configuration::Configuration, team_id: &str, name: &str) -> Result<Vec<crate::models::Channel>, Error<TeamsTeamIdChannelsAutocompleteGetError>> {
        let client = &configuration.client;

        let uri_str = format!("{}/teams/{team_id}/channels/autocomplete", configuration.base_path, team_id=crate::apis::urlencode(team_id));
        let mut req_builder = client.get(uri_str.as_str());

        req_builder = req_builder.query(&[("name", &name.to_string())]);
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<TeamsTeamIdChannelsAutocompleteGetError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn teams_team_id_channels_deleted_get(configuration: &configuration::Configuration, team_id: &str, page: Option<i32>, per_page: Option<i32>) -> Result<Vec<crate::models::Channel>, Error<TeamsTeamIdChannelsDeletedGetError>> {
        let client = &configuration.client;

        let uri_str = format!("{}/teams/{team_id}/channels/deleted", configuration.base_path, team_id=crate::apis::urlencode(team_id));
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = page {
            req_builder = req_builder.query(&[("page", &s.to_string())]);
        }
        if let Some(ref s) = per_page {
            req_builder = req_builder.query(&[("per_page", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<TeamsTeamIdChannelsDeletedGetError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn teams_team_id_channels_get(configuration: &configuration::Configuration, team_id: &str, page: Option<i32>, per_page: Option<i32>) -> Result<Vec<crate::models::Channel>, Error<TeamsTeamIdChannelsGetError>> {
        let client = &configuration.client;

        let uri_str = format!("{}/teams/{team_id}/channels", configuration.base_path, team_id=crate::apis::urlencode(team_id));
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = page {
            req_builder = req_builder.query(&[("page", &s.to_string())]);
        }
        if let Some(ref s) = per_page {
            req_builder = req_builder.query(&[("per_page", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<TeamsTeamIdChannelsGetError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn teams_team_id_channels_ids_post(configuration: &configuration::Configuration, team_id: &str, request_body: Vec<String>) -> Result<Vec<crate::models::Channel>, Error<TeamsTeamIdChannelsIdsPostError>> {
        let client = &configuration.client;

        let uri_str = format!("{}/teams/{team_id}/channels/ids", configuration.base_path, team_id=crate::apis::urlencode(team_id));
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };
        req_builder = req_builder.json(&request_body);

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<TeamsTeamIdChannelsIdsPostError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn teams_team_id_channels_name_channel_name_get(configuration: &configuration::Configuration, team_id: &str, channel_name: &str, include_deleted: Option<bool>) -> Result<crate::models::Channel, Error<TeamsTeamIdChannelsNameChannelNameGetError>> {
        let client = &configuration.client;

        let uri_str = format!("{}/teams/{team_id}/channels/name/{channel_name}", configuration.base_path, team_id=crate::apis::urlencode(team_id), channel_name=crate::apis::urlencode(channel_name));
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = include_deleted {
            req_builder = req_builder.query(&[("include_deleted", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<TeamsTeamIdChannelsNameChannelNameGetError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn teams_team_id_channels_search_archived_post(configuration: &configuration::Configuration, team_id: &str, inline_object46: crate::models::InlineObject46) -> Result<Vec<crate::models::Channel>, Error<TeamsTeamIdChannelsSearchArchivedPostError>> {
        let client = &configuration.client;

        let uri_str = format!("{}/teams/{team_id}/channels/search_archived", configuration.base_path, team_id=crate::apis::urlencode(team_id));
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };
        req_builder = req_builder.json(&inline_object46);

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<TeamsTeamIdChannelsSearchArchivedPostError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn teams_team_id_channels_search_autocomplete_get(configuration: &configuration::Configuration, team_id: &str, name: &str) -> Result<Vec<crate::models::Channel>, Error<TeamsTeamIdChannelsSearchAutocompleteGetError>> {
        let client = &configuration.client;

        let uri_str = format!("{}/teams/{team_id}/channels/search_autocomplete", configuration.base_path, team_id=crate::apis::urlencode(team_id));
        let mut req_builder = client.get(uri_str.as_str());

        req_builder = req_builder.query(&[("name", &name.to_string())]);
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<TeamsTeamIdChannelsSearchAutocompleteGetError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn teams_team_id_channels_search_post(configuration: &configuration::Configuration, team_id: &str, inline_object45: crate::models::InlineObject45) -> Result<Vec<crate::models::Channel>, Error<TeamsTeamIdChannelsSearchPostError>> {
        let client = &configuration.client;

        let uri_str = format!("{}/teams/{team_id}/channels/search", configuration.base_path, team_id=crate::apis::urlencode(team_id));
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };
        req_builder = req_builder.json(&inline_object45);

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<TeamsTeamIdChannelsSearchPostError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn users_user_id_channels_channel_id_unread_get(configuration: &configuration::Configuration, user_id: &str, channel_id: &str) -> Result<crate::models::ChannelUnread, Error<UsersUserIdChannelsChannelIdUnreadGetError>> {
        let client = &configuration.client;

        let uri_str = format!("{}/users/{user_id}/channels/{channel_id}/unread", configuration.base_path, user_id=crate::apis::urlencode(user_id), channel_id=crate::apis::urlencode(channel_id));
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<UsersUserIdChannelsChannelIdUnreadGetError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn users_user_id_teams_team_id_channels_get(configuration: &configuration::Configuration, user_id: &str, team_id: &str) -> Result<Vec<crate::models::Channel>, Error<UsersUserIdTeamsTeamIdChannelsGetError>> {
        let client = &configuration.client;

        let uri_str = format!("{}/users/{user_id}/teams/{team_id}/channels", configuration.base_path, user_id=crate::apis::urlencode(user_id), team_id=crate::apis::urlencode(team_id));
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<UsersUserIdTeamsTeamIdChannelsGetError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

    pub async fn users_user_id_teams_team_id_channels_members_get(configuration: &configuration::Configuration, user_id: &str, team_id: &str) -> Result<Vec<crate::models::ChannelMember>, Error<UsersUserIdTeamsTeamIdChannelsMembersGetError>> {
        let client = &configuration.client;

        let uri_str = format!("{}/users/{user_id}/teams/{team_id}/channels/members", configuration.base_path, user_id=crate::apis::urlencode(user_id), team_id=crate::apis::urlencode(team_id));
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        if let Some(ref token) = configuration.bearer_access_token {
            req_builder = req_builder.bearer_auth(token.to_owned());
        };

        let req = req_builder.build()?;
        let resp = client.execute(req).await?;

        let status = resp.status();
        let content = resp.text().await?;

        if status.is_success() {
            serde_json::from_str(&content).map_err(Error::from)
        } else {
            let entity: Option<UsersUserIdTeamsTeamIdChannelsMembersGetError> = serde_json::from_str(&content).ok();
            let error = ResponseContent { status, content, entity };
            Err(Error::ResponseError(error))
        }
    }

